#单例
>是一个仅实例化一次的类[Gamma95]。单例对象通常表示无状态对象，如函数 (条目 24) 或一个本质上唯一
的系统组件。让一个类成为单例会使测试它的客户变得困难，因为除非实现一个作为它类型的接口，否则不可能用一
个模拟实现替代单例。
有两种常见的方法来实现单例。两者都基于保持构造方法私有和导出公共静态成员以提供对唯一实例的访问。在

## 第一种方法中，成员是 final 修饰的属性
 - 是 API 明确表示该类是一个单例：公共静态属性是 final 的，所以它总是包含相同的对象引用。

## 第二个实现单例的方法中，公共成员是一个静态的工厂方法
- 优点
  - 它可以灵活地改变你的想法(单例类，可能不是单例类)，无论该类是否为单例而不必更改其 API。(用静态方法返回)
  - 如果你的应用程序需要它，可以编写一个泛型单例工厂（generic singleton factory ）（条目 30）
  - 是方法引用可以用 supplier，例如 Elvis::instance 等同于 Supplier<Elvis>
- 单例的序列化与反序列化
  - implements Serializable 添加到声明
  - 为了维护单例的保证，声明所有的实例属性为 transient，并提供一个 readResolve 方法 (条目 89)。否则，每当序列化实例被反序列化时，就会创建一个新的实例

## 枚举单例
- 优点：这种方式类似于公共属性方法，但更简洁，提供了免费的序列化机制，并提供了针对多个实例化的坚固保证，即使是在复杂的序列化或反射攻击的情况下。
- 缺点：如果单例必须继承 Enum 以外的父类 (尽管可以声明一个 Enum 来实现接口)，那么就不能使用这种方法。
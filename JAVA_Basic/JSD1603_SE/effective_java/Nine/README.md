# 前言
>一个很常见的错误根源在于没有覆盖 hashCode 方法。在每个覆盖了 equals 方法的类中，也
必须覆盖 hashCode 方法。如果不这样做的话，就会违反 Object.hashcode 的通用约定，从而
导致该类无法结合所有基于散列的集合一起正常工作，这样的集合包
括 HashMap 、 HashSet 和 Hashtable 。

#下面是约定的内容，摘自 Object 规范[JavaSE6]：  
- 在应用程序的执行期间，只要对象的 equals 方法的比较操作所用到的信息没有被修改，
那么对同一个对象调用多次， hashCode 方法都必须始终如一地返回同一个整数。在同一
个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。  
- 如果两个对象根据 equals(Object) 方法比较是相等的，那么调用这两个对象中任意一个
对象的 hashCode 方法都必须产生同样的整数结果。  
- 如果两个对象根据 equals(Object) 方法比较是不相等的，那么调用这两个对象中任意一
个对象的 hashCode 方法，则不一定要产生不同的整数结果。但是程序员应该知道，给不
相等的对象产生截然不同的整数结果，有可能提高散列表（hash table）的性能。  


`// The worst possible legal hash function - never use!  
@Override public int hashCode() { return 42; }`  
上面这个 hashCode 方法是合法的，因为它确保了相等的对象总是具有同样的散列码。但它也
极为恶劣，因为它使得每个对象都具有同样的散列码。因此，每个对象都被映射到同一个散
列桶中，使散列表退化为链表（linked list）。它使得本该线性时间运行的程序变成了以平方
级时间在运行。对于规模很大的散列表而言，这会关系到散列表能否正常工作。  
一个好的散列函数通常倾向于“为不相等的对象产生不相等的散列码”。这正是 hashCode 约定
中第三条的含义。理想情况下，散列函数应该把集合中不相等的实例均匀地分不到所有可能
的散列值上。要想完全达到这种理想的情形是非常困难的。幸运的是，相对接近这种理想情
形则并不太苦难。下面给出一种简单的解决办法：  
1. 把某个非零的常数值，比如说17，保存在一个名为 result 的 int 类型的变量中。  
2. 对于对象中每个关键域 f （指 equals 方法中涉及的每个域），完成以下步骤：  
   a. 为该域计算 int 类型的散列码 CC :  
   i. 如果该域是 boolean 类型，则计算 (f ? 1 : 0) .  
   ii. 如果该域是 byte 、 char 、 short 或者 int 类型，则计算 (int)f 。  
   iii. 如果该域是 long 类型，则计算 (int)(f ^ (f >>> 32)) 。  
   iv. 如果该域是 float 类型，则计算 Float.floatToIntBits(f) 。  
   v. 如果该域是 double 类型，则计算 Double.doubleToLongBits(f) ，然后按照步骤2.a.iii，为得到的 long 类型值计算散列值。  
   vi. 如果该域是一个对象引用，并且该域的 equals 方法通过递归地调用 equals 的方式来
   比较这个域，则同样为这个域递归地调用 hashCode 。如果需要更复杂的比较，则为这个
   域计算一个“范式（canonical representation）”，然后针对这个范式调用 hashCode 。如
   果这个域的值为 null ，则返回0（或者其他某个常数，但通常是0）。  
   vii. 如果该域是一个数组，则要把每一个元素当做单独的域来处理。也就是说，递归地应
   用上述规则，对每个重要的元素计算一个散列码，然后根据步骤2.b中的做法把这些散列
   值组合起来。如果数组域中的每个元素都很重要，可以利用发行版本1.5中增加的其中一 个 Arrays.hashCode 方法。  
   b. 按照下面的公式，把步骤2.a中计算得到的散列码 CC 合并到 result 中：
   result = 31 * result + CC;
3. 返回result。  
4. 注意情况：  
   1. 把冗余域（redundant field）排除在外。换句话说，如果一个域
      的值可以根据参与计算的其他域值计算出来，则可以把这样的域排除在外。必须排
      除 equals 比较计算中没有用到的任何域，否则很有可能违反 hashCode 约定的第二条。  
   2. 上述步骤1中用到了一个非零的初始值，因此步骤2.a中计算的散列值为0的那些初始域，会影
      响到散列值。如果步骤1中的初始值为0，则整个散列值将不受这些初始域的影响，因为这些
      初始域会增加冲突的可能性。值 17 则是任选的  
   3. 
      1. 步骤2.b中的乘法部分使得散列值依赖于域的顺序，如果一个类包含多个相似的域，这样的乘
         法运算就会产生一个更好的散列函数；
      2. 之所以选择31，是因为它是一个奇素数。如果乘数是偶数，并且乘法溢出的话，信息就会丢失，因为与2相乘等价于位移运算。
         使用素数的好处并不很明显，但是习惯上都使用素数来计算散列结果。**31有个很好的特性**，
         即用位移和减法来代替乘法，可以得到更好的性能， **31 * i == (i << 5) - i** 。现代的VM可
         以自动完成这种优化。
   4. 如果一个类是不可变的，并且**计算散列码的开销也比较大，就应该考虑把散列码缓存在对象
      内部**，而不是每次请求的时候都重新计算散列码。如果你**觉得这种类型的大多数对象会被用
      作散列键（hash keys）**，_就应该在创建实例的时候计算散列码_。否则，可以选择“延迟初始化
      （lazily initialize）”散列码，一直到 hashCode 被第一次调用的时候才初始化（见第71条）  

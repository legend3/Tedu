# 前言
>必须在每个重写equal()的类中重写hashCode。如果您没有这样做，您的类将违反hashCode的通用契约， 
这将阻止它在HashMap和HashSet等集合中正常工作(当对象被当作元素放入键值对的数据类型时！)。
以下是改编自对象规范的契约:

1. 当在应用程序执行期间在对象上重复调用hashCode方法时，如果没有修改相等比较中使用的信息，
则该方法必须始终返回相同的值。在应用程序的一次执行到另一次执行期间，该值不必保持一致。

2. 如果根据equals(Object)方法，两个对象相等，那么在这两个对象上调用hashCode必须产生相同的整数结果。

3. 如果根据equals(Object)方法，两个对象是不相等的，则不要求对每个对象调用hashCode必须产生不同的结果。
但是，程序员应该意识到，为不相等的对象产生不同的结果可能会提高哈希表的性能。  


> **当您未能覆盖hashCode时，违反了第二个提供key的规定:**相等的对象必须具有相等的哈希码。
根据类的equals方法，两个**不同**的实例在*逻辑上*可能是相等的，但是
对象的hashCode方法，它们只是两个没有太多共同点的对象。因此，Object的hashCode方法返回两个看似随机的数字，而不是契约要求的两个相等的数字。 

## 一个好的哈希函数往往会为不同的实例产生不同的哈希码。这正是hashCode契约的第三部分的含义。
>理想情况下，哈希函数应该将任何合理的不相等实例集合均匀地分布在所有int值上。实现这一理想可能很困难。
幸运的是，得到一个合理的近似并不太难。这里有一个简单的秘诀:  
1. 声明一个名为result的int变量，并将其初始化为对象中第一个重要字段(field)的散列代码c，如步骤2.a中计算的那样。(回忆
   第10项重要字段是影响相等比较的字段。)  
   `int result = Short.hashCode(areaCode);`
2. 对于对象中*剩余的有效字段f*，执行以下操作：  
   a. **为字段计算一个int散列代码c:**  
   i. 如果字段是*原始类型*，则计算type.hashcode (f)，其中
   Type是与f的类型对应的装箱基元类.  
   ii. 如果字段是一个对象引用，并且该类的equals方法通过递归地调用equals来比较字段，则递归地调用字段上的hashCode。
如果需要更复杂的比较，请计算该字段的“规范表示”，并对规范表示调用hashCode。如果该字段的值为null，则使用0(或其他常量，但0是传统的)。   
   iii. 如果字段是一个数组，则将其视为每个重要元素都是一个单独的字段(field)。
也就是说，通过**递归地应用这些规则**来计算每个重要元素(数组内重要的元素，而不是全部)的哈希代码，并在步骤2.b中组合这些值。如果数组没有有效元素，则使用常数，最好不要为0。
如果所有元素都重要，请使用Arrays.hashCode。 
   car. **结合步骤2.a中计算的哈希代码c转化为如下结果:**
   i. result = 31 * result + c;
3. 返回result。  
4. 注意情况：  
   1. 把冗余域（redundant field）排除在外。换句话说，如果一个域
      的值可以根据参与计算的其他域值计算出来，则可以把这样的域排除在外。必须排
      除 equals 比较计算中没有用到的任何域，否则很有可能违反 hashCode 约定的第二条。  
   2. 上述步骤1中用到了一个非零的初始值，因此步骤2.a中计算的散列值为0的那些初始域，会影
      响到散列值。如果步骤1中的初始值为0，则整个散列值将不受这些初始域的影响，因为这些
      初始域会增加冲突的可能性。值 17 则是任选的  
   3. 
      1. 步骤2.b中的乘法部分使得散列值依赖于域的顺序，如果一个类包含多个相似的域，这样的乘
         法运算就会产生一个更好的散列函数；
      2. 之所以选择31，是因为它是一个奇素数。如果乘数是偶数，并且乘法溢出的话，信息就会丢失，因为与2相乘等价于位移运算。
         使用素数的好处并不很明显，但是习惯上都使用素数来计算散列结果。**31有个很好的特性**，
         即用位移和减法来代替乘法，可以得到更好的性能， **31 * i == (i << 5) - i** 。现代的VM可
         以自动完成这种优化。
   4. 如果一个类是不可变的，并且**计算散列码的开销也比较大，就应该考虑把散列码缓存在对象
      内部**，而不是每次请求的时候都重新计算散列码。如果你**觉得这种类型的大多数对象会被用
      作散列键（hash keys）**，_就应该在创建实例的时候计算散列码_。否则，可以选择“延迟初始化
      （lazily initialize）”散列码，一直到 hashCode 被第一次调用的时候才初始化（见第71条）  

回顾:
1.重写Override:
  1)父子类，方法签名相同，方法体不同
  2)重写方法被调用时，看对象的类型
2.重写与重载的区别:
  1)重写:父子类，方法签名相同，方法体不同
         运行期绑定，看对象
  2)重载:一个类，方法名相同，参数列表不同
         编译期绑定，看引用
3.package和import
4.访问控制修饰符:
  public:公开的，任何类
  private:私有的，本类
  protected:受保护的，本类、子类、同包类
  默认的:什么也不写，本类、同包类
5.static:静态的
  1)静态变量:
      static，属于类，方法区，一份，类名.
      所有对象数据都一样，只有一份
  2)静态方法:
      static，属于类，方法区，一份，类名.
      没有隐式的this，不能直接访问实例成员
      方法的操作仅与参数相关而与对象无关
  3)静态块:
      static，属于类，类被加载期间自动执行，一次
      常常用于加载静态资源
6.final:不可变的
  1)修饰变量:变量不能被改变
  2)修饰方法:方法不能被重写
  3)修饰类  :类不能被继承


package a;
class Aoo{
}

package b;
class Aoo{
}

package c;
class Moo{
  void show(){
    a.Aoo o = new a.Aoo();
    b.Aoo o1 = new b.Aoo();
  }
}










笔记:
1.static final常量:
  1)必须声明同时初始化
  2)通过类名.来访问，不能被改变
  3)建议:常量名所有字母都大写
  4)在编译时被直接替换为具体的值--效率高
2.抽象方法:
  1)由abstract修饰
  2)只有方法的定义，没有方法的具体实现(连大括号都没有)
3.抽象类:
  1)由abstract修饰
  2)包含抽象方法的类必须是抽象类
    不包含抽象方法的类也可以声明为抽象类-----我愿意
  3)抽象类不能被实例化
  4)抽象类是需要被继承的，子类:
    4.1)重写抽象类中的所有抽象方法---建议方式
    4.2)也声明为抽象类----一般不这样做
  5)抽象类的意义:
    5.1)封装子类所共有的数据和方法，被子类共用
    5.2)为所有子类提供了一种统一的类型--向上造型
    5.3)包含抽象方法，为所有子类提供一个统一的入口
4.接口:
  1)是一个标准、规范
    遵守了这个标准，就能干某件事----API之后
  2)由interface定义
  3)只能包含常量和抽象方法
  4)接口不能被实例化
  5)接口是需要被实现/继承的，实现类/子类:
      必须重写接口中的所有!!抽象方法
  6)一个类可以实现多个接口，用逗号隔开
    若又继承又实现时，要先继承后实现
  7)接口可以继承接口


接口是对继承的单根性的扩展





今天任务:
1.创建oo.day06包
    要求:把今天银行卡系统的代码----重写一次

周末任务:
1.一周的经典案例重做一次
2.自学:
    抽象类与接口的区别是什么?
    何时用抽象类？何时用接口?















UnionPayTest








interface UnionPay{ //银联接口
  void 存();
  void 取();
  void 查询余额();
  void 转帐();
}
interface ICBC extends UnionPay{ //工行
  void 在线支付();
}
interface ABC extends UnionPay{ //农行
  void 支付电话费();
}

class ICBCImpl implements ICBC{ //工行卡
  public void 存(){}
  public void 取(){}
  public void 查询余额(){}
  public void 转帐(){}
  public void 在线支付(){}
}
class ABCImpl implements ABC{ //农行卡
  public void 存(){}
  public void 取(){}
  public void 查询余额(){}
  public void 转帐(){}
  public void 支付电话费(){}
}



if(balance-number==0)-------钱正好够
if(balance-number>100)------取完钱之后多100
if(balance-number>-2000)----取完钱之后少2000



double num = input.nextDouble();











类和类-----------extends
接口和接口-------extends
类和接口---------implements

extends-------同类型的
implements----不同类型的


Inter1 o1 = new Inter1(); //编译错误

Inter2 o2 = new Aoo(); //向上造型
Inter1 o3 = new Aoo();

interface Inter1{
  void a();
}
interface Inter2 extends Inter1{
  void b();
}
class Aoo implements Inter2{
  public void b(){}
  public void a(){}
}













interface Inter1{
  void a();
}
interface Inter2{
  void b();
}
abstract class Aoo{
  abstract void c();
}
class Boo extends Aoo implements Inter1,Inter2{
  public void a(){}
  public void b(){}
  void c(){}
}






interface Inter1{
  void a();
  void b();
}
class Aoo implements Inter1{
  public void a(){}
  public void b(){}
}






interface Inter1{ //不完整
  public static final int NUM=5;
  public abstract void show();

  double PI=3.14159; //默认public static final
  void test(); //默认public abstract

  int a; //编译错误
  void say(){} //编译错误
}









现实生活中的接口:
1)电脑厂商做了USB接口-----制定标准、规范
  U盘、鼠标、摄像头等等---遵守标准、规范
2)国家对商品房------------制定标准、规范
  国家对家具、家电--------制定标准、规范
  开发商、家具家电厂商----遵守标准、规范
3)银行--------------------制定标准、规范
  银行卡------------------遵守标准、规范



















存款，取款，转帐，支付电话费----农行













new Tetromino(); //编译错误

new T();
new J();
new O();

abstract class Tetromino{ //我愿意
  Cell[] cells;
  void drop(){
  }
  void moveLeft(){
  }
  void moveRight(){
  }
  void print(){
  }
}
class T extends Tetromino{
}
class J extends Tetromino{
}
class O extends Tetromino{
}




ShapeTest，包含main，把注释删掉



我讲你能听得懂但写不出来-------不需要留级










凡是动物都能run()，但是每个动物具体的行为是不一样的



abstract class Animal{
  abstract void run();
}
class Bird extends Animal{
  void run(){
    在天上飞
  }
}
class Tiger extends Animal{
  void run(){
    在地上跑
  }
}
class Fish extends Animal{
  void run(){
    在水里游
  }
}








给我一组图形，求这一组图形的最大面积
Square[] ss = new Square[3];
ss[0] = new Square(1);
ss[1] = new Square(2);
ss[2] = new Square(3);

Circle[] cs = new Cricle[3];
cs[0] = new Circle(1);
cs[1] = new Circle(2);
cs[2] = new Circle(3);

Six[] sixes = new Six[3];
sixes[0] = new Six(1);
sixes[1] = new Six(2);
sixes[2] = new Six(3);

1)找到ss中的最大面积sMax
2)找到cs中的最大面积cMax
3)找到sixes中的最大面积sixMax
4)找到sMax与cMax与sixMax中的最大值max



假设:我将9个图形都能装在一个数组中

new Shape(); //编译错误
Shape s = new Square(1); //向上造型
Shape s = new Circle(1);
Shape s = new Six(1);



Shape[] shapes = new Shape[9]; //创建Shape数组对象
shapes[0] = new Square(1);
shapes[1] = new Square(2);
shapes[2] = new Square(3);
shapes[3] = new Circle(1);
shapes[4] = new Circle(2);
shapes[5] = new Circle(3);
shapes[6] = new Six(1);
shapes[7] = new Six(2);
shapes[8] = new Six(3);

1)能点出来什么，看引用的类型
2)重写方法被调时，看对象的类型

double max = shapes[0].area();
for(int i=1;i<shapes.length;i++){
  double area = shapes[i].area();
  if(area>max){
    max=area;
  }
}
System.out.println("最大面积为:"+max);
Shape s1  = new Circle();
Shape s2  = new Square();


Circle s2 = new Circle();

abstract class Shape{ //抽象类-不完整
  double c;
  abstract double area(); //抽象方法-不完整
}
class Square extends Shape{
  double area(){ //重写--变不完整为完整
    return 0.0625*c*c;
  }
}
class Circle extend Shape{
  double area(){
    return 0.0796*c*c;
  }
}



















Shape s; //正确
new Shape(); //编译错误

abstract class Shape{ //抽象类--不完整
  double c;
  abstract double area(); //抽象方法--不完整
}

class Square extends Shape{ //方形
  double area(){ //重写--变不完整为完整
    return 0.0625*c*c;
  }
}
class Circle extends Shape{ //圆形
  double area(){
    return 0.0796*c*c;
  }
}








abstract class Six extends Shape{ //六边形
}


new Car();

abstract class Car{
  ...
  abstract void stop();
}
















